
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-04-26"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Part 1: MIMO</a></li><li><a href="#3">Background</a></li><li><a href="#4">Parameter Setup</a></li><li><a href="#5">Transmit Precoding and Receiver Shaping Scheme</a></li><li><a href="#6">Zero Forcing Scheme</a></li><li><a href="#7">MMSE Scheme</a></li><li><a href="#8">MIMO BER Curves</a></li><li><a href="#9">Part 2: OFDM</a></li><li><a href="#10">Parameter Setup</a></li><li><a href="#11">Zero Forcing Scheme</a></li><li><a href="#12">MMSE Scheme</a></li><li><a href="#13">Plot BER Curves</a></li><li><a href="#14">Part 3: MIMO-OFDM</a></li><li><a href="#15">Parmeter Setup</a></li><li><a href="#16">OFDM Zero-Forcing, MIMO Precoding/Zero-Forcing/MMSE</a></li><li><a href="#17">OFDM MMSE, MIMO Precoding/Zero-Forcing/MMSE</a></li><li><a href="#18">Plot BER Curves</a></li></ul></div><pre class="codeinput"><span class="comment">% ECE408 - Wireless Communications</span>
<span class="comment">% Jongoh (Andy) Jeong</span>
<span class="comment">% Project: MIMO, OFDM, MIMO-OFDM</span>
<span class="comment">% Date: April 29, 2020</span>
clear <span class="string">all</span>; close <span class="string">all</span>; clc;
warning (<span class="string">'off'</span>,<span class="string">'all'</span>);

<span class="comment">% Reference:</span>
<span class="comment">%</span>
<span class="comment">% [1] Stuber et al. $Broadband MIMO-OFDM Wireless Communications$</span>
</pre><h2 id="2">Part 1: MIMO</h2><p>model a 2x2 MIMO link with flat fading gains and 3 equalizer schemes: Pre-coding, Zero-forcing and MMSE  Pre-coding has CSIT, where Zero-forcing and MMSE has CSIR</p><h2 id="3">Background</h2><p>Single-User MIMO system with 2 Tx and 2 Rx antennas are described below:</p><p><img vspace="5" hspace="5" src="SU_MIMO.png" alt=""> </p><p>Reference: [2] <a href="https://www.sharetechnote.com/html/BasicProcedure_LTE_MIMO.html">https://www.sharetechnote.com/html/BasicProcedure_LTE_MIMO.html</a></p><h2 id="4">Parameter Setup</h2><pre class="codeinput">M = 16;          <span class="comment">% modulation order</span>
k = log2(M);     <span class="comment">% coded bits per symbol</span>
nSyms = 1e3/2;     <span class="comment">% number of symbols to send</span>
nBits = nSyms * k;

nChan = 3;      <span class="comment">% number of flat fading MIMO channels</span>
EbNo = -10:2:30; <span class="comment">% Eb/No</span>
snrVector = EbNo + 10*log10(k); <span class="comment">% Es/No before adding noise</span>

<span class="comment">% 2 x 2 MIMO channel</span>
Mt = 2;
Mr = 2;

<span class="comment">% initialize</span>
berPreCoding = zeros(nChan, length(snrVector));
berZeroForcing = zeros(nChan, length(snrVector));
berMMSE = zeros(nChan, length(snrVector));
</pre><h2 id="5">Transmit Precoding and Receiver Shaping Scheme</h2><p><img vspace="5" hspace="5" src="mimo_precoding_descriptions.png" alt=""> </p><p>Reference: Goldsmith, <img src="main_eq11461178088147398812.png" alt="$Wireless Communications$"> [pp. 323-324]</p><pre class="codeinput"><span class="comment">% Transmit precoding: x = V*(x_hat)</span>
<span class="comment">% Receiver shaping: (y_hat) = (U_hermitian_transposed)*y</span>
U = zeros(Mr, Mt, nBits);
S = zeros(Mr, Mt, nBits);
V = zeros(Mr, Mt, nBits);
prefiltered = zeros(Mt, 1, nBits);
txData = zeros(Mt, 1, nBits);
postfiltered = zeros(Mr, 1, nBits);
rxData = zeros(Mr, 1, nBits);

disp(<span class="string">'MIMO precoding'</span>);
<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\n'</span>,i);
    <span class="comment">% unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas</span>
    H = ( randn(Mr, Mt, nBits) + 1j*randn(Mr, Mt, nBits) ) / sqrt(2);

    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    data = randi([0 M-1], Mt, 1, nBits);
    dataMod = qammod(data, M);

    <span class="comment">% precode</span>
    <span class="keyword">for</span> bit = 1:nBits
        <span class="comment">% decompose channel matrix H by SVD</span>
        [U(:,:,bit), S(:,:,bit), V(:,:,bit)] = svd(H(:,:,bit));
        <span class="comment">% pre-code data for each bit: inverting fading at transmitter (x = V * x_hat)</span>
        prefiltered(:,:,bit) = V(:,:,bit) * dataMod(:,:,bit);
        <span class="comment">% send over the fading channel</span>
        txData(:,:,bit) = H(:,:,bit)*prefiltered(:,:,bit);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
       fprintf(<span class="string">'%d\t'</span>,j);
       <span class="comment">% add white Gaussian noise (x_noisy &lt;-- x + noise)</span>
       <span class="comment">% for double-sided white noise, account for 1/2 in power (y_hat = U^(H) * y)</span>
       noise = randn(Mr, 1, nBits) + 1j*randn(Mr, 1, nBits) / sqrt(2);
       txNoisy = txData +  noise * 10^(-snrVector(j)/10/2);
       <span class="keyword">for</span> bit = 1:nBits
           <span class="comment">% post-code data for each bit: remove fading channel components</span>
           postfiltered(:,:,bit) = U(:,:,bit)' * txNoisy(:,:,bit);
           <span class="comment">% recover data</span>
           rxData(:,:,bit) = S(:,:,bit)^-1 * postfiltered(:,:,bit);
       <span class="keyword">end</span>

       <span class="comment">% QAM demodulate and compute bit error rate</span>
       rxData = qamdemod(rxData,M);
       [~,berPreCoding(i,j)] = biterr(data, rxData);
    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>
<span class="comment">% take average of all 3 fading channels</span>
berPreCoding = mean(berPreCoding);
</pre><pre class="codeoutput">MIMO precoding
Channel: 1
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><h2 id="6">Zero Forcing Scheme</h2><pre class="codeinput">txData = zeros(Mt, 1, nBits);
rxData = zeros(Mr, 1, nBits);
W = zeros(Mr, Mt, nBits);

disp(<span class="string">'MIMO zero forcing'</span>);
<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\n'</span>,i);
    <span class="comment">% unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas</span>
    H = ( randn(Mr, Mt, nBits) + 1j*randn(Mr, Mt, nBits) ) / sqrt(2);

    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    data = randi([0 M-1], Mt, 1, nBits);
    dataMod = qammod(data, M);

    <span class="keyword">for</span> bit = 1:nBits
        <span class="comment">% send over the fading channel</span>
        txData(:,:,bit) = H(:,:,bit) * dataMod(:,:,bit);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
       fprintf(<span class="string">'%d\t'</span>,j);
       <span class="comment">% add white Gaussian noise (x_noisy &lt;-- x + noise)</span>
       <span class="comment">% for double-sided white noise, account for 1/2 in power (y_hat = U^(H) * y)</span>
       noise = randn(Mr, 1, nBits) + 1j*randn(Mr, 1, nBits) / sqrt(2);
       txNoisy = txData +  noise * 10^(-snrVector(j)/10/2);

       <span class="keyword">for</span> bit = 1:nBits
           <span class="comment">% (1) W_{zf} = H_{Pseudoinverse} = (H^{H} * H)^{-1} * H^{H}</span>
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit))^-1 * H(:,:,bit)';
           rxData(:,:,bit) = W(:,:,bit) * txNoisy(:,:,bit);
           <span class="comment">% (2) or simply solve linear system H*x = y for x, if full rank</span>
           <span class="comment">% rxData(:,:,bit) = H(:,:,bit) \ txNoisy(:,:,bit);</span>
       <span class="keyword">end</span>

       <span class="comment">% QAM demodulate and compute bit error rate</span>
       rxData = qamdemod(rxData,M);
       [~,berZeroForcing(i,j)] = biterr(data, rxData);
    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>
<span class="comment">% take average of all 3 fading channels</span>
berZeroForcing = mean(berZeroForcing);
</pre><pre class="codeoutput">MIMO zero forcing
Channel: 1
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><h2 id="7">MMSE Scheme</h2><pre class="codeinput">txData = zeros(Mt, 1, nBits);
rxData = zeros(Mr, 1, nBits);
W = zeros(Mr, Mt, nBits);

disp(<span class="string">'MIMO MMSE'</span>);
<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\n'</span>,i);
    <span class="comment">% unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas</span>
    H = ( randn(Mr, Mt, nBits) + 1j*randn(Mr, Mt, nBits) ) / sqrt(2);

    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    data = randi([0 M-1], Mt, 1, nBits);
    dataMod = qammod(data, M);

    <span class="keyword">for</span> bit = 1:nBits
        <span class="comment">% send over the fading channel</span>
        txData(:,:,bit) = H(:,:,bit) * dataMod(:,:,bit);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
       fprintf(<span class="string">'%d\t'</span>,j);
       <span class="comment">% add white Gaussian noise (x_noisy &lt;-- x + noise)</span>
       <span class="comment">% for double-sided white noise, account for 1/2 in power (y_hat = U^(H) * y)</span>
       noise = randn(Mr, 1, nBits) + 1j*randn(Mr, 1, nBits) / sqrt(2);
       txNoisy = txData +  noise * 10^(-snrVector(j)/10/2);

       <span class="keyword">for</span> bit = 1:nBits
           <span class="comment">% add noise variations before taking inverse of the first parenthesis</span>
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit) + <span class="keyword">...</span>
                         + eye(Mt)*10^(-snrVector(j)/10/2) <span class="keyword">...</span>
                         )^-1 * H(:,:,bit)';
           rxData(:,:,bit) = W(:,:,bit) * txNoisy(:,:,bit);
       <span class="keyword">end</span>

       <span class="comment">% QAM demodulate and compute bit error rate</span>
       rxData = qamdemod(rxData,M);
       [~,berMMSE(i,j)] = biterr(data, rxData);
    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>
<span class="comment">% take average of all 3 fading channels</span>
berMMSE = mean(berMMSE);
</pre><pre class="codeoutput">MIMO MMSE
Channel: 1
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><h2 id="8">MIMO BER Curves</h2><pre class="codeinput">figure;
semilogy(EbNo, berPreCoding,<span class="string">'-o'</span>, <span class="keyword">...</span>
         EbNo, berZeroForcing ,<span class="string">'-v'</span>, <span class="keyword">...</span>
         EbNo, berMMSE,<span class="string">'-s'</span>,<span class="string">'LineWidth'</span>,1);
grid <span class="string">on</span>;
xlim([EbNo(1)-2 EbNo(end)+2]);
title(sprintf(<span class="string">'%d Tx x %d Rx MIMO: BER Curves by Equalizer, M = %d QAM'</span>, Mt, Mr, M));
set(gca, <span class="string">'FontWeight'</span>,<span class="string">'bold'</span>,<span class="string">'LineWidth'</span>,1);
xlabel(<span class="string">'Eb/No (dB)'</span>);
ylabel(<span class="string">'Bit Error Rate (avg over 3 flat fading channels)'</span>);
legend(<span class="string">'Pre-Coding'</span>,<span class="string">'Zero Forcing'</span>,<span class="string">'MMSE'</span>);
snapnow;
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <h2 id="9">Part 2: OFDM</h2><p>Reference:</p><p>- mmse equalizer: [3] <a href="https://www.researchgate.net/publication/313955547_Performance_of_MMSE_channel_equalization_for_MIMO_OFDM_system">https://www.researchgate.net/publication/313955547_Performance_of_MMSE_channel_equalization_for_MIMO_OFDM_system</a></p><p>- 801.11a: [4] <a href="http://rfmw.em.keysight.com/wireless/helpfi0les/89600b/webhelp/subsystems/wlan-ofdm/Content/ofdm_80211-overview.htm">http://rfmw.em.keysight.com/wireless/helpfi0les/89600b/webhelp/subsystems/wlan-ofdm/Content/ofdm_80211-overview.htm</a></p><p>[5] Goldsmith, <img src="main_eq11461178088147398812.png" alt="$Wireless Communications$">, [p.397]</p><pre class="codeinput"><span class="comment">% assume perfect CSIR</span>
</pre><h2 id="10">Parameter Setup</h2><pre class="codeinput"><span class="comment">% close all; clear all; clc;</span>
<span class="comment">% warning ('off','all');</span>

<span class="comment">% 802.11a</span>
<span class="comment">% &gt;&gt; each OFDM symbol has a total of 80 for data samples and cyclic prefix</span>
<span class="comment">%   - N = 64 subcarriers are generated,</span>
<span class="comment">%       of which 48 are used for data tx, 12 are zeroed to reduce ISI,</span>
<span class="comment">%       4 used for pilot symbols for channel estimation;</span>
<span class="comment">%   - subcarriers are evenly spaced over 20 MHz bandwidth into 312.5 kHz</span>
<span class="comment">%   - CP: 16 samples</span>


nSubcarrier = 64;               <span class="comment">% number of subcarriers</span>
nCP = 16;                       <span class="comment">% length of cyclic prefix</span>
nData = nSubcarrier - nCP;      <span class="comment">% number of subcarriers used for data</span>
nPilot = 4;                     <span class="comment">% number of pilots</span>

M = 16;                         <span class="comment">% modulation order: 16 (QAM)</span>
nChan = 3;                      <span class="comment">% number of unique (random) Rayleigh channels</span>
nSyms = 1e3/2;                    <span class="comment">% number of OFDM symbols</span>

<span class="comment">% single Rayleigh frequency selective channel with 4 taps by 802.11a PHY standard</span>
Ts = 4e-6;                      <span class="comment">% symbol time per subchannel (sampling period of channel)</span>
Fd = 0;                         <span class="comment">% maximum Doppler frequency shift (Hz)</span>
tau = [0 1e-5 3.5e-5 12e-5];    <span class="comment">% path delays for 4 paths</span>
pdb = [0 -1 -1 -3];             <span class="comment">% average path power gains in each path</span>
h = rayleighchan(Ts, Fd, tau, pdb);
h.StoreHistory = 0;
h.StorePathGains = 1;
h.ResetBeforeFiltering = 1;

EbNo = -10:2:30;
snrVector = EbNo + 10*log10(nSubcarrier/(nSubcarrier+nCP));

<span class="comment">% initialize ber vectors</span>
berZeroForcing = zeros(nChan, length(snrVector));
berMMSE = zeros(nChan, length(snrVector));
</pre><h2 id="11">Zero Forcing Scheme</h2><pre class="codeinput"><span class="comment">% initialize</span>
chan = zeros(nSubcarrier+nCP, nSyms);
txData = zeros(nSubcarrier+nCP, nSyms);

disp(<span class="string">'OFDM zero forcing'</span>);
<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\t'</span>,i);
    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    msg = randi([0 M-1], 1, nData*nSyms);
    dataMod = qammod(msg, M);
    dataMod = reshape(dataMod, nData,[]);

    <span class="comment">% 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI</span>
    frame = zeros(nSubcarrier, nSyms);
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame(dataIdx,:) = dataMod;             <span class="comment">% data</span>
    frame(nData+1:nData+nPilot,:) = 1;      <span class="comment">% pilot</span>
    dataIFFT = ifft(frame,64);              <span class="comment">% 64-point IFFT</span>

    <span class="comment">% insert cyclic prefix</span>
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];

    <span class="comment">% OFDM encode (flat fading Rayleigh channel)</span>
    <span class="keyword">for</span> k=1:nSyms
        chan(:,k) = filter(h,ones((nSubcarrier+nCP),1));
        txData(:,k) = chan(:,k) .* dataIFFTWithCP(:,k);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
        fprintf(<span class="string">'%d\t'</span>,j);
        noise = (randn(nSubcarrier+nCP,nSyms)+1j*randn(nSubcarrier+nCP,nSyms)) / sqrt(2);
        txNoisy = txData + 10^(-snrVector(j)/10/2) * noise;

        <span class="comment">% take 64-point FFT back on data + zero + pilot portion (w/o CP)</span>
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, nSubcarrier);

        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:)) ./ conj(chan(nCP+1:end,:)));
        ofdmZF = rxFFT ./ W;

        ofdmRxData = ofdmZF(dataIdx,:);
        ofdmRxDataToDemod = reshape(ofdmRxData,1,[]);
        rxData = qamdemod(ofdmRxDataToDemod, M);
        [~, berZeroForcing(i,j)] = biterr(msg, rxData);

    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">OFDM zero forcing
Channel: 1	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><h2 id="12">MMSE Scheme</h2><pre class="codeinput"><span class="comment">% initialize</span>
chan = zeros(nSubcarrier+nCP, nSyms);
txData = zeros(nSubcarrier+nCP, nSyms);
rxData = zeros(1, nData * nSyms);

disp(<span class="string">'OFDM MMSE'</span>);
<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\n'</span>,i);
    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    msg = randi([0 M-1], 1, nData*nSyms);
    dataMod = qammod(msg, M);
    dataMod = reshape(dataMod, nData,[]);

    <span class="comment">% 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI</span>
    frame = zeros(nSubcarrier, nSyms);
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame(dataIdx,:) = dataMod;             <span class="comment">% data</span>
    frame(nData+1:nData+nPilot,:) = 1;      <span class="comment">% pilot</span>
    dataIFFT = ifft(frame,64);              <span class="comment">% 64-point IFFT</span>

    <span class="comment">% insert cyclic prefix</span>
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];

    <span class="comment">% OFDM encode (flat fading Rayleigh channel)</span>
    <span class="keyword">for</span> k=1:nSyms
        chan(:,k) = filter(h,ones((nSubcarrier+nCP),1));
        txData(:,k) = chan(:,k).* dataIFFTWithCP(:,k);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
        fprintf(<span class="string">'%d\t'</span>,j);
        noise = (randn(nSubcarrier+nCP,nSyms)+1j*randn(nSubcarrier+nCP,nSyms)) / sqrt(2);
        noiseSNR = 10^(-snrVector(j)/10/2);
        txNoisy = txData + noise * noiseSNR;

        <span class="comment">% take 64-point FFT back on data + zero + pilot portion (w/o CP)</span>
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, nSubcarrier);

        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:) + <span class="keyword">...</span>
            ones(nSubcarrier, nSyms).*noiseSNR) ./ conj(chan(nCP+1:end,:)));
        ofdmMMSE = rxFFT ./ W;

        ofdmRxData = ofdmMMSE(dataIdx,:);
        ofdmRxDataToDemod = reshape(ofdmRxData,1,[]);
        rxData = qamdemod(ofdmRxDataToDemod, M);
        [~, berMMSE(i,j)] = biterr(msg, rxData);

    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">OFDM MMSE
Channel: 1
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3
SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><h2 id="13">Plot BER Curves</h2><pre class="codeinput">figure;
semilogy(EbNo, mean(berZeroForcing),<span class="string">'-o'</span>, <span class="keyword">...</span>
         EbNo, mean(berMMSE),<span class="string">'-v'</span>,<span class="string">'LineWidth'</span>,1);
grid <span class="string">on</span>;
xlim([EbNo(1)-2 EbNo(end)+2]);
title(sprintf(<span class="string">'OFDM in Rayleigh Channel: BER Curves by Equalizers, M = %d QAM'</span>, M));
set(gca, <span class="string">'FontWeight'</span>,<span class="string">'bold'</span>,<span class="string">'LineWidth'</span>,1);
xlabel(<span class="string">'Eb/No (dB)'</span>);
ylabel(<span class="string">'Bit Error Rate (avg over 3 flat fading channels)'</span>);
legend(<span class="string">'Zero Forcing'</span>,<span class="string">'MMSE'</span>);
snapnow;
</pre><img vspace="5" hspace="5" src="main_02.png" alt=""> <h2 id="14">Part 3: MIMO-OFDM</h2><pre class="codeinput"><span class="comment">% close all; clear all; clc;</span>
<span class="comment">% warning ('off','all');</span>

<span class="comment">% Take the OFDM symbol and put it through a 2x2 frequency selective MIMO link.</span>
<span class="comment">% You can assume perfect CSIT or CSIR, whichever you want.</span>
<span class="comment">% The magic of OFDM and MIMO is the frequency selective MIMO channel</span>
<span class="comment">% just becomes a bunch of independent flat fading MIMO channels.</span>

<span class="comment">% assume perfect CSIR</span>
</pre><h2 id="15">Parmeter Setup</h2><pre class="codeinput">nChan = 3;                      <span class="comment">% number of unique (random) Rayleigh channels</span>
nSyms = 1e2/2;                     <span class="comment">% number of symbols to transmit</span>
M = 16;                         <span class="comment">% modulation order: 16 (QAM)</span>
k = log2(M);
nBits = nSyms * k;

<span class="comment">% MIMO</span>
Mt = 2;
Mr = 2;

<span class="comment">% OFDM</span>
nSubcarrier = 64;               <span class="comment">% number of subcarriers</span>
nCP = 16;                       <span class="comment">% length of cyclic prefix</span>
nData = nSubcarrier - nCP;      <span class="comment">% number of subcarriers used for data</span>
nPilot = 4;                     <span class="comment">% number of pilots</span>

<span class="comment">% single Rayleigh frequency selective channel with 4 taps by 802.11a PHY standard</span>
Ts = 4e-6;                      <span class="comment">% symbol time per subchannel (sampling period of channel)</span>
Fd = 0;                         <span class="comment">% maximum Doppler frequency shift (Hz)</span>
tau = [0 1e-5 3.5e-5 12e-5];    <span class="comment">% path delays for 4 paths</span>
pdb = [0 -1 -1 -3];             <span class="comment">% average path power gains in each path</span>
h = rayleighchan(Ts, Fd, tau, pdb);
h.StoreHistory = 0;
h.StorePathGains = 1;
h.ResetBeforeFiltering = 1;

<span class="comment">% SNR</span>
EbNo = -10:2:30;
snrVector = EbNo + 10*log10(k) + 10*log10(nSubcarrier/(nSubcarrier+nCP));

<span class="comment">% initialize</span>
nMIMOequalizers = 3;
berOFDMZeroForcing = zeros(nChan, length(snrVector), nMIMOequalizers);
berOFDMmmse = zeros(nChan, length(snrVector), nMIMOequalizers);
H = zeros(Mr, Mt, nData*nSyms*k);

<span class="comment">% order:</span>
<span class="comment">% data src - MIMO (3) - OFDM (2) - AWGN - OFDM (2) - MIMO (3) - data sink</span>
<span class="comment">% assume perfect CSIT; estimate CSIR</span>
</pre><h2 id="16">OFDM Zero-Forcing, MIMO Precoding/Zero-Forcing/MMSE</h2><pre class="codeinput"><span class="comment">% initialize</span>
U = zeros(Mr, Mt, nData*nSyms*k);
S = zeros(Mr, Mt, nData*nSyms*k);
V = zeros(Mr, Mt, nData*nSyms*k);
chan = zeros(nSubcarrier+nCP, nSyms);
txOFDM = zeros(nSubcarrier+nCP, nSyms*k*Mt);
prefiltered = zeros(Mr,1,nData*nSyms*k);
txMIMO = zeros(Mr,1,nData*nSyms*k);
postfiltered = zeros(Mr,1,nData*nSyms*k);
rxMIMO = zeros(Mr,1,nData*nSyms*k);

<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\t'</span>,i);

    <span class="comment">% unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas</span>
    H = ( randn(Mr, Mt, nData*nSyms*k) + 1j*randn(Mr, Mt, nData*nSyms*k) ) / sqrt(2);

    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    msg = randi([0 M-1], 1, nData*nSyms*k*Mt);
    bits = reshape(msg, 2, []);
    dataMod = qammod(bits, M);

    <span class="comment">% reshape for OFDM framing</span>
    txMsg = reshape(dataMod, nData,[]);

    <span class="comment">% OFDM: 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI</span>
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame = zeros(nSubcarrier, nSyms*k*Mt);
    frame(dataIdx,:) = txMsg;              <span class="comment">% data</span>
    frame(nData+1:nData+nPilot,:) = 1;      <span class="comment">% pilot</span>
    dataIFFT = ifft(frame,64);              <span class="comment">% 64-point IFFT</span>

    <span class="comment">% OFDM: insert cyclic prefix (CP)</span>
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];

    <span class="comment">% OFDM encode (flat fading Rayleigh channel)</span>
    <span class="keyword">for</span> kk = 1:nSyms*k*Mt
        chan(:,kk) = filter(h,ones((nSubcarrier+nCP),1));
        txOFDM(:,kk) = chan(:,kk) .* dataIFFTWithCP(:,kk);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
        fprintf(<span class="string">'%d\t'</span>,j);
        <span class="comment">% add noise from OFDM modulation</span>
        noise = (randn(nSubcarrier+nCP,nSyms*k*Mt) + 1j*randn(nSubcarrier+nCP,nSyms*k*Mt)) / sqrt(2);
        txNoisy = txOFDM + 10^(-snrVector(j)/10/2) * noise;

        <span class="comment">% OFDM: take 64-point FFT back on data + zero + pilot portion (w/o CP)</span>
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, 64); <span class="comment">% 64-point FFT</span>

        <span class="comment">% OFDM: Equalize</span>
        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:)) ./ conj(chan(nCP+1:end,:)));
        ofdmZF = rxFFT ./ W;
        ofdmRxData = ofdmZF(dataIdx,:);

        <span class="comment">% OFDM frame</span>
        OFDMsym = reshape(ofdmRxData, 1, []);

        <span class="comment">% prepare to send over MIMO channel</span>
        txMIMOsym = reshape(OFDMsym, Mt, 1, []);

        <span class="comment">% ---- MIMO precoding</span>
        <span class="comment">% precode and send over channel</span>
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            <span class="comment">% decompose channel matrix H by SVD</span>
            [U(:,:,bit), S(:,:,bit), V(:,:,bit)] = svd(H(:,:,bit));
            <span class="comment">% pre-code data for each bit: inverting fading at transmitter (x = V * x_hat)</span>
            prefiltered(:,:,bit) = V(:,:,bit) * txMIMOsym(:,:,bit);
            <span class="comment">% send over the fading channel</span>
            txMIMO(:,:,bit) = H(:,:,bit)*prefiltered(:,:,bit);
        <span class="keyword">end</span>

        <span class="comment">% add noise from MIMO channel</span>
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;

        <span class="keyword">for</span> bit = 1:nData*nSyms*k
           <span class="comment">% post-code data for each bit: remove fading channel components</span>
           postfiltered(:,:,bit) = U(:,:,bit)' * txMIMONoisy(:,:,bit);
           <span class="comment">% recover data</span>
           rxMIMO(:,:,bit) = S(:,:,bit)^-1 * postfiltered(:,:,bit);
        <span class="keyword">end</span>
        rxMIMOPrecoded = rxMIMO;
        clear <span class="string">rxMIMO</span>;

        <span class="comment">% ---- MIMO zero forcing</span>
        <span class="comment">% pass through channel</span>
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        <span class="keyword">end</span>
        <span class="comment">% add noise from MIMO channel</span>
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        clear <span class="string">W</span>;
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit))^-1 * H(:,:,bit)';
           rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        <span class="keyword">end</span>
        rxMIMOzf = rxMIMO;
        clear <span class="string">rxMIMO</span>;

        <span class="comment">% ---- MIMO MMSE</span>
                <span class="comment">% pass through channel</span>
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        <span class="keyword">end</span>
        <span class="comment">% add noise from MIMO channel</span>
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;

        clear <span class="string">W</span>;
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit) + <span class="keyword">...</span>
                          + eye(Mt)*10^(-snrVector(j)/10/2) <span class="keyword">...</span>
                          )^-1 * H(:,:,bit)';
            rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        <span class="keyword">end</span>
        rxMIMOmmse = rxMIMO;
        clear <span class="string">rxMIMO</span>;

        <span class="comment">% QAM demodulate and compute bit error rate</span>
        rxDataPC = qamdemod(rxMIMOPrecoded, M);
        rxDataZF = qamdemod(rxMIMOzf, M);
        rxDataMMSE = qamdemod(rxMIMOmmse, M);

        rxDataMsgPC = reshape(rxDataPC, 1, []);
        rxDataMsgZF = reshape(rxDataZF, 1, []);
        rxDataMsgMMSE = reshape(rxDataMMSE, 1, []);

        [~,berOFDMZeroForcing(i,j,1)] = biterr(msg, rxDataMsgPC);
        [~,berOFDMZeroForcing(i,j,2)] = biterr(msg, rxDataMsgZF);
        [~,berOFDMZeroForcing(i,j,3)] = biterr(msg, rxDataMsgMMSE);

    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>

berOFDMZeroForcing = mean(berOFDMZeroForcing,1);
berOFDMZeroForcing = permute(berOFDMZeroForcing, [3 2 1]);
</pre><pre class="codeoutput">Channel: 1	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><img vspace="5" hspace="5" src="main_03.png" alt=""> <h2 id="17">OFDM MMSE, MIMO Precoding/Zero-Forcing/MMSE</h2><pre class="codeinput"><span class="comment">% initialize</span>
U = zeros(Mr, Mt, nData*nSyms*k);
S = zeros(Mr, Mt, nData*nSyms*k);
V = zeros(Mr, Mt, nData*nSyms*k);
chan = zeros(nSubcarrier+nCP, nSyms);
txOFDM = zeros(nSubcarrier+nCP, nSyms*k*Mt);
prefiltered = zeros(Mr,1,nData*nSyms*k);
txMIMO = zeros(Mr,1,nData*nSyms*k);
postfiltered = zeros(Mr,1,nData*nSyms*k);
rxMIMO = zeros(Mr,1,nData*nSyms*k);

<span class="keyword">for</span> i = 1:nChan
    fprintf(<span class="string">'Channel: %d\t'</span>,i);

    <span class="comment">% unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas</span>
    H = ( randn(Mr, Mt, nData*nSyms*k) + 1j*randn(Mr, Mt, nData*nSyms*k) ) / sqrt(2);

    <span class="comment">% generate a sequence of random message bits and QAM modulate</span>
    msg = randi([0 M-1], 1, nData*nSyms*k*Mt);
    bits = reshape(msg, 2, []);
    dataMod = qammod(bits, M);

    <span class="comment">% reshape for OFDM framing</span>
    txMsg = reshape(dataMod, nData,[]);

    <span class="comment">% OFDM: 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI</span>
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame = zeros(nSubcarrier, nSyms*k*Mt);
    frame(dataIdx,:) = txMsg;              <span class="comment">% data</span>
    frame(nData+1:nData+nPilot,:) = 1;      <span class="comment">% pilot</span>
    dataIFFT = ifft(frame,64);              <span class="comment">% 64-point IFFT</span>

    <span class="comment">% OFDM: insert cyclic prefix (CP)</span>
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];

    <span class="comment">% OFDM encode (flat fading Rayleigh channel)</span>
    <span class="keyword">for</span> kk = 1:nSyms*k*Mt
        chan(:,kk) = filter(h,ones((nSubcarrier+nCP),1));
        txOFDM(:,kk) = chan(:,kk) .* dataIFFTWithCP(:,kk);
    <span class="keyword">end</span>

    fprintf(<span class="string">'SNR:\t'</span>);
    <span class="keyword">for</span> j = 1:length(snrVector)
        fprintf(<span class="string">'%d\t'</span>,j);
        <span class="comment">% add noise from OFDM modulation</span>
        noise = (randn(nSubcarrier+nCP,nSyms*k*Mt) + 1j*randn(nSubcarrier+nCP,nSyms*k*Mt)) / sqrt(2);
        noiseSNR = 10^(-snrVector(j)/10/2);
        txNoisy = txOFDM + noiseSNR * noise;

        <span class="comment">% OFDM: take 64-point FFT back on data + zero + pilot portion (w/o CP)</span>
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, 64); <span class="comment">% 64-point FFT</span>

        <span class="comment">% OFDM: Equalize</span>
        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:) + <span class="keyword">...</span>
            ones(nSubcarrier, nSyms*k*Mt).*noiseSNR) ./ conj(chan(nCP+1:end,:)));
        ofdmMMSE = rxFFT ./ W;
        ofdmRxData = ofdmMMSE(dataIdx,:);

        <span class="comment">% OFDM frame</span>
        OFDMsym = reshape(ofdmRxData, 1, []);

        <span class="comment">% prepare to send over MIMO channel</span>
        txMIMOsym = reshape(OFDMsym, Mt, 1, []);

        <span class="comment">% ---- MIMO precoding</span>
        <span class="comment">% precode and send over channel</span>
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            <span class="comment">% decompose channel matrix H by SVD</span>
            [U(:,:,bit), S(:,:,bit), V(:,:,bit)] = svd(H(:,:,bit));
            <span class="comment">% pre-code data for each bit: inverting fading at transmitter (x = V * x_hat)</span>
            prefiltered(:,:,bit) = V(:,:,bit) * txMIMOsym(:,:,bit);
            <span class="comment">% send over the fading channel</span>
            txMIMO(:,:,bit) = H(:,:,bit)*prefiltered(:,:,bit);
        <span class="keyword">end</span>

        <span class="comment">% add noise from MIMO channel</span>
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;

        <span class="keyword">for</span> bit = 1:nData*nSyms*k
           <span class="comment">% post-code data for each bit: remove fading channel components</span>
           postfiltered(:,:,bit) = U(:,:,bit)' * txMIMONoisy(:,:,bit);
           <span class="comment">% recover data</span>
           rxMIMO(:,:,bit) = S(:,:,bit)^-1 * postfiltered(:,:,bit);
        <span class="keyword">end</span>
        rxMIMOPrecoded = rxMIMO;
        clear <span class="string">rxMIMO</span>;

        <span class="comment">% ---- MIMO zero forcing</span>
        <span class="comment">% pass through channel</span>
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        <span class="keyword">end</span>
        <span class="comment">% add noise from MIMO channel</span>
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        clear <span class="string">W</span>;
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit))^-1 * H(:,:,bit)';
           rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        <span class="keyword">end</span>
        rxMIMOzf = rxMIMO;
        clear <span class="string">rxMIMO</span>;

        <span class="comment">% ---- MIMO MMSE</span>
                <span class="comment">% pass through channel</span>
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        <span class="keyword">end</span>
        <span class="comment">% add noise from MIMO channel</span>
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;

        clear <span class="string">W</span>;
        <span class="keyword">for</span> bit = 1:nData*nSyms*k
            W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit) + <span class="keyword">...</span>
                          + eye(Mt)*10^(-snrVector(j)/10/2) <span class="keyword">...</span>
                          )^-1 * H(:,:,bit)';
            rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        <span class="keyword">end</span>
        rxMIMOmmse = rxMIMO;
        clear <span class="string">rxMIMO</span>;

        <span class="comment">% QAM demodulate and compute bit error rate</span>
        rxDataPC = qamdemod(rxMIMOPrecoded, M);
        rxDataZF = qamdemod(rxMIMOzf, M);
        rxDataMMSE = qamdemod(rxMIMOmmse, M);

        rxDataMsgPC = reshape(rxDataPC, 1, []);
        rxDataMsgZF = reshape(rxDataZF, 1, []);
        rxDataMsgMMSE = reshape(rxDataMMSE, 1, []);

        [~,berOFDMmmse(i,j,1)] = biterr(msg, rxDataMsgPC);
        [~,berOFDMmmse(i,j,2)] = biterr(msg, rxDataMsgZF);
        [~,berOFDMmmse(i,j,3)] = biterr(msg, rxDataMsgMMSE);

    <span class="keyword">end</span>
    fprintf(<span class="string">'\n'</span>);
<span class="keyword">end</span>

berOFDMmmse = mean(berOFDMmmse,1);
berOFDMmmse = permute(berOFDMmmse, [3 2 1]);
</pre><pre class="codeoutput">Channel: 1	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 2	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
Channel: 3	SNR:	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	
</pre><h2 id="18">Plot BER Curves</h2><pre class="codeinput">figure(<span class="string">'Renderer'</span>, <span class="string">'painters'</span>, <span class="string">'Position'</span>, [300 300 900 600])
semilogy(EbNo, berOFDMZeroForcing(1,:), <span class="string">'-bo'</span>, <span class="keyword">...</span>
         EbNo, berOFDMZeroForcing(2,:), <span class="string">'-b^'</span>, <span class="keyword">...</span>
         EbNo, berOFDMZeroForcing(3,:), <span class="string">'-bv'</span>, <span class="string">'LineWidth'</span>,1);
hold <span class="string">on</span>;
semilogy(EbNo, berOFDMmmse(1,:), <span class="string">'-ko'</span>, <span class="keyword">...</span>
         EbNo, berOFDMmmse(2,:), <span class="string">'-k^'</span>, <span class="keyword">...</span>
         EbNo, berOFDMmmse(3,:), <span class="string">'-kv'</span>, <span class="string">'LineWidth'</span>,1);
grid <span class="string">on</span>;
xlim([EbNo(1)-2 EbNo(end)+2]);
legend(<span class="string">'OFDM ZF, MIMO Precoding'</span>,<span class="string">'OFDM ZF, MIMO Zero Forcing'</span>,<span class="string">'OFDM ZF, MIMO MMSE'</span>, <span class="keyword">...</span>
       <span class="string">'OFDM MMSE, MIMO Precoding'</span>,<span class="string">'OFDM MMSE, MIMO Zero Forcing'</span>,<span class="string">'OFDM MMSE, MIMO MMSE'</span>);
title(sprintf(<span class="string">'MIMO-OFDM: BER Curves by Equalizers, M = %d QAM'</span>, M));
set(gca, <span class="string">'FontWeight'</span>,<span class="string">'bold'</span>,<span class="string">'LineWidth'</span>,1);
xlabel(<span class="string">'Eb/No (dB)'</span>);
ylabel(<span class="string">'Bit Error Rate (avg over 3 flat fading channels)'</span>);
snapnow;
</pre><img vspace="5" hspace="5" src="main_04.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
% ECE408 - Wireless Communications
% Jongoh (Andy) Jeong
% Project: MIMO, OFDM, MIMO-OFDM
% Date: April 29, 2020
clear all; close all; clc;
warning ('off','all');

% Reference:
% 
% [1] Stuber et al. $Broadband MIMO-OFDM Wireless Communications$ 

%% Part 1: MIMO
% model a 2x2 MIMO link with flat fading gains and 3 equalizer schemes: Pre-coding, Zero-forcing and MMSE
% ** Pre-coding has CSIT, where Zero-forcing and MMSE has CSIR

%% Background
% Single-User MIMO system with 2 Tx and 2 Rx antennas are described below:
%
% <<SU_MIMO.png>>
%
% Reference: 
% [2] https://www.sharetechnote.com/html/BasicProcedure_LTE_MIMO.html

%% Parameter Setup

M = 16;          % modulation order
k = log2(M);     % coded bits per symbol
nSyms = 1e3/2;     % number of symbols to send
nBits = nSyms * k;

nChan = 3;      % number of flat fading MIMO channels
EbNo = -10:2:30; % Eb/No
snrVector = EbNo + 10*log10(k); % Es/No before adding noise

% 2 x 2 MIMO channel
Mt = 2;
Mr = 2;

% initialize
berPreCoding = zeros(nChan, length(snrVector));
berZeroForcing = zeros(nChan, length(snrVector));
berMMSE = zeros(nChan, length(snrVector));

%% Transmit Precoding and Receiver Shaping Scheme
%
% <<mimo_precoding_descriptions.png>>
%
% Reference: Goldsmith, $Wireless Communications$ [pp. 323-324]

% Transmit precoding: x = V*(x_hat)
% Receiver shaping: (y_hat) = (U_hermitian_transposed)*y
U = zeros(Mr, Mt, nBits);
S = zeros(Mr, Mt, nBits);
V = zeros(Mr, Mt, nBits);
prefiltered = zeros(Mt, 1, nBits);
txData = zeros(Mt, 1, nBits);
postfiltered = zeros(Mr, 1, nBits);
rxData = zeros(Mr, 1, nBits);

disp('MIMO precoding');
for i = 1:nChan
    fprintf('Channel: %d\n',i);
    % unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas
    H = ( randn(Mr, Mt, nBits) + 1j*randn(Mr, Mt, nBits) ) / sqrt(2);

    % generate a sequence of random message bits and QAM modulate
    data = randi([0 M-1], Mt, 1, nBits);
    dataMod = qammod(data, M);
    
    % precode
    for bit = 1:nBits
        % decompose channel matrix H by SVD
        [U(:,:,bit), S(:,:,bit), V(:,:,bit)] = svd(H(:,:,bit));
        % pre-code data for each bit: inverting fading at transmitter (x = V * x_hat)
        prefiltered(:,:,bit) = V(:,:,bit) * dataMod(:,:,bit);
        % send over the fading channel
        txData(:,:,bit) = H(:,:,bit)*prefiltered(:,:,bit);
    end
    
    fprintf('SNR:\t');
    for j = 1:length(snrVector)
       fprintf('%d\t',j);
       % add white Gaussian noise (x_noisy <REPLACE_WITH_DASH_DASH x + noise)
       % for double-sided white noise, account for 1/2 in power (y_hat = U^(H) * y)
       noise = randn(Mr, 1, nBits) + 1j*randn(Mr, 1, nBits) / sqrt(2);
       txNoisy = txData +  noise * 10^(-snrVector(j)/10/2);
       for bit = 1:nBits
           % post-code data for each bit: remove fading channel components
           postfiltered(:,:,bit) = U(:,:,bit)' * txNoisy(:,:,bit);
           % recover data
           rxData(:,:,bit) = S(:,:,bit)^-1 * postfiltered(:,:,bit);
       end
       
       % QAM demodulate and compute bit error rate
       rxData = qamdemod(rxData,M);
       [~,berPreCoding(i,j)] = biterr(data, rxData); 
    end
    fprintf('\n');
end
% take average of all 3 fading channels
berPreCoding = mean(berPreCoding);

%% Zero Forcing Scheme

txData = zeros(Mt, 1, nBits);
rxData = zeros(Mr, 1, nBits);
W = zeros(Mr, Mt, nBits);

disp('MIMO zero forcing');
for i = 1:nChan
    fprintf('Channel: %d\n',i);
    % unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas
    H = ( randn(Mr, Mt, nBits) + 1j*randn(Mr, Mt, nBits) ) / sqrt(2);

    % generate a sequence of random message bits and QAM modulate
    data = randi([0 M-1], Mt, 1, nBits);
    dataMod = qammod(data, M);
    
    for bit = 1:nBits
        % send over the fading channel
        txData(:,:,bit) = H(:,:,bit) * dataMod(:,:,bit);
    end
    
    fprintf('SNR:\t');
    for j = 1:length(snrVector)
       fprintf('%d\t',j);
       % add white Gaussian noise (x_noisy <REPLACE_WITH_DASH_DASH x + noise)
       % for double-sided white noise, account for 1/2 in power (y_hat = U^(H) * y)
       noise = randn(Mr, 1, nBits) + 1j*randn(Mr, 1, nBits) / sqrt(2);
       txNoisy = txData +  noise * 10^(-snrVector(j)/10/2);
       
       for bit = 1:nBits
           % (1) W_{zf} = H_{Pseudoinverse} = (H^{H} * H)^{-1} * H^{H}
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit))^-1 * H(:,:,bit)';
           rxData(:,:,bit) = W(:,:,bit) * txNoisy(:,:,bit);
           % (2) or simply solve linear system H*x = y for x, if full rank
           % rxData(:,:,bit) = H(:,:,bit) \ txNoisy(:,:,bit);
       end
       
       % QAM demodulate and compute bit error rate
       rxData = qamdemod(rxData,M);
       [~,berZeroForcing(i,j)] = biterr(data, rxData); 
    end
    fprintf('\n');
end
% take average of all 3 fading channels
berZeroForcing = mean(berZeroForcing);

%% MMSE Scheme

txData = zeros(Mt, 1, nBits);
rxData = zeros(Mr, 1, nBits);
W = zeros(Mr, Mt, nBits);

disp('MIMO MMSE');
for i = 1:nChan
    fprintf('Channel: %d\n',i);
    % unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas
    H = ( randn(Mr, Mt, nBits) + 1j*randn(Mr, Mt, nBits) ) / sqrt(2);

    % generate a sequence of random message bits and QAM modulate
    data = randi([0 M-1], Mt, 1, nBits);
    dataMod = qammod(data, M);
    
    for bit = 1:nBits
        % send over the fading channel
        txData(:,:,bit) = H(:,:,bit) * dataMod(:,:,bit);
    end

    fprintf('SNR:\t');
    for j = 1:length(snrVector)
       fprintf('%d\t',j);
       % add white Gaussian noise (x_noisy <REPLACE_WITH_DASH_DASH x + noise)
       % for double-sided white noise, account for 1/2 in power (y_hat = U^(H) * y)
       noise = randn(Mr, 1, nBits) + 1j*randn(Mr, 1, nBits) / sqrt(2);
       txNoisy = txData +  noise * 10^(-snrVector(j)/10/2);
       
       for bit = 1:nBits
           % add noise variations before taking inverse of the first parenthesis
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit) + ...
                         + eye(Mt)*10^(-snrVector(j)/10/2) ...
                         )^-1 * H(:,:,bit)';
           rxData(:,:,bit) = W(:,:,bit) * txNoisy(:,:,bit);
       end
       
       % QAM demodulate and compute bit error rate
       rxData = qamdemod(rxData,M);
       [~,berMMSE(i,j)] = biterr(data, rxData); 
    end
    fprintf('\n');
end
% take average of all 3 fading channels
berMMSE = mean(berMMSE);

%% MIMO BER Curves

figure;
semilogy(EbNo, berPreCoding,'-o', ...
         EbNo, berZeroForcing ,'-v', ...
         EbNo, berMMSE,'-s','LineWidth',1);
grid on;
xlim([EbNo(1)-2 EbNo(end)+2]);
title(sprintf('%d Tx x %d Rx MIMO: BER Curves by Equalizer, M = %d QAM', Mt, Mr, M));
set(gca, 'FontWeight','bold','LineWidth',1);
xlabel('Eb/No (dB)');
ylabel('Bit Error Rate (avg over 3 flat fading channels)');
legend('Pre-Coding','Zero Forcing','MMSE');
snapnow;

%% Part 2: OFDM
% Reference:
%
% - mmse equalizer:
% [3] https://www.researchgate.net/publication/313955547_Performance_of_MMSE_channel_equalization_for_MIMO_OFDM_system
%
% - 801.11a:
% [4] http://rfmw.em.keysight.com/wireless/helpfi0les/89600b/webhelp/subsystems/wlan-ofdm/Content/ofdm_80211-overview.htm
%
% [5] Goldsmith, $Wireless Communications$, [p.397]

% assume perfect CSIR

%% Parameter Setup

% close all; clear all; clc;
% warning ('off','all');

% 802.11a
% >> each OFDM symbol has a total of 80 for data samples and cyclic prefix
%   - N = 64 subcarriers are generated, 
%       of which 48 are used for data tx, 12 are zeroed to reduce ISI, 
%       4 used for pilot symbols for channel estimation;
%   - subcarriers are evenly spaced over 20 MHz bandwidth into 312.5 kHz
%   - CP: 16 samples


nSubcarrier = 64;               % number of subcarriers
nCP = 16;                       % length of cyclic prefix
nData = nSubcarrier - nCP;      % number of subcarriers used for data
nPilot = 4;                     % number of pilots

M = 16;                         % modulation order: 16 (QAM)
nChan = 3;                      % number of unique (random) Rayleigh channels
nSyms = 1e3/2;                    % number of OFDM symbols

% single Rayleigh frequency selective channel with 4 taps by 802.11a PHY standard
Ts = 4e-6;                      % symbol time per subchannel (sampling period of channel)
Fd = 0;                         % maximum Doppler frequency shift (Hz)
tau = [0 1e-5 3.5e-5 12e-5];    % path delays for 4 paths
pdb = [0 -1 -1 -3];             % average path power gains in each path
h = rayleighchan(Ts, Fd, tau, pdb);
h.StoreHistory = 0;
h.StorePathGains = 1;
h.ResetBeforeFiltering = 1;

EbNo = -10:2:30;
snrVector = EbNo + 10*log10(nSubcarrier/(nSubcarrier+nCP));

% initialize ber vectors
berZeroForcing = zeros(nChan, length(snrVector));
berMMSE = zeros(nChan, length(snrVector));

%% Zero Forcing Scheme

% initialize
chan = zeros(nSubcarrier+nCP, nSyms);
txData = zeros(nSubcarrier+nCP, nSyms);

disp('OFDM zero forcing');
for i = 1:nChan
    fprintf('Channel: %d\t',i);
    % generate a sequence of random message bits and QAM modulate
    msg = randi([0 M-1], 1, nData*nSyms);
    dataMod = qammod(msg, M);
    dataMod = reshape(dataMod, nData,[]);
    
    % 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI
    frame = zeros(nSubcarrier, nSyms);
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame(dataIdx,:) = dataMod;             % data
    frame(nData+1:nData+nPilot,:) = 1;      % pilot
    dataIFFT = ifft(frame,64);              % 64-point IFFT
    
    % insert cyclic prefix
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];
    
    % OFDM encode (flat fading Rayleigh channel)
    for k=1:nSyms        
        chan(:,k) = filter(h,ones((nSubcarrier+nCP),1));
        txData(:,k) = chan(:,k) .* dataIFFTWithCP(:,k);
    end
    
    fprintf('SNR:\t');
    for j = 1:length(snrVector)
        fprintf('%d\t',j);
        noise = (randn(nSubcarrier+nCP,nSyms)+1j*randn(nSubcarrier+nCP,nSyms)) / sqrt(2);
        txNoisy = txData + 10^(-snrVector(j)/10/2) * noise;
                
        % take 64-point FFT back on data + zero + pilot portion (w/o CP)
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, nSubcarrier);
        
        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:)) ./ conj(chan(nCP+1:end,:)));
        ofdmZF = rxFFT ./ W;

        ofdmRxData = ofdmZF(dataIdx,:);
        ofdmRxDataToDemod = reshape(ofdmRxData,1,[]);
        rxData = qamdemod(ofdmRxDataToDemod, M);
        [~, berZeroForcing(i,j)] = biterr(msg, rxData);
        
    end
    fprintf('\n');
end

%% MMSE Scheme

% initialize
chan = zeros(nSubcarrier+nCP, nSyms);
txData = zeros(nSubcarrier+nCP, nSyms);
rxData = zeros(1, nData * nSyms);

disp('OFDM MMSE');
for i = 1:nChan
    fprintf('Channel: %d\n',i);
    % generate a sequence of random message bits and QAM modulate
    msg = randi([0 M-1], 1, nData*nSyms);
    dataMod = qammod(msg, M);
    dataMod = reshape(dataMod, nData,[]);
    
    % 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI
    frame = zeros(nSubcarrier, nSyms);
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame(dataIdx,:) = dataMod;             % data
    frame(nData+1:nData+nPilot,:) = 1;      % pilot
    dataIFFT = ifft(frame,64);              % 64-point IFFT
    
    % insert cyclic prefix
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];

    % OFDM encode (flat fading Rayleigh channel)
    for k=1:nSyms
        chan(:,k) = filter(h,ones((nSubcarrier+nCP),1));
        txData(:,k) = chan(:,k).* dataIFFTWithCP(:,k);
    end
    
    fprintf('SNR:\t');
    for j = 1:length(snrVector)
        fprintf('%d\t',j);
        noise = (randn(nSubcarrier+nCP,nSyms)+1j*randn(nSubcarrier+nCP,nSyms)) / sqrt(2);
        noiseSNR = 10^(-snrVector(j)/10/2);
        txNoisy = txData + noise * noiseSNR;
        
        % take 64-point FFT back on data + zero + pilot portion (w/o CP)
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, nSubcarrier);
        
        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:) + ...
            ones(nSubcarrier, nSyms).*noiseSNR) ./ conj(chan(nCP+1:end,:)));
        ofdmMMSE = rxFFT ./ W;
        
        ofdmRxData = ofdmMMSE(dataIdx,:);
        ofdmRxDataToDemod = reshape(ofdmRxData,1,[]);
        rxData = qamdemod(ofdmRxDataToDemod, M);
        [~, berMMSE(i,j)] = biterr(msg, rxData);
        
    end
    fprintf('\n');
end

%% Plot BER Curves
figure;
semilogy(EbNo, mean(berZeroForcing),'-o', ...
         EbNo, mean(berMMSE),'-v','LineWidth',1);
grid on;
xlim([EbNo(1)-2 EbNo(end)+2]);
title(sprintf('OFDM in Rayleigh Channel: BER Curves by Equalizers, M = %d QAM', M));
set(gca, 'FontWeight','bold','LineWidth',1);
xlabel('Eb/No (dB)');
ylabel('Bit Error Rate (avg over 3 flat fading channels)');
legend('Zero Forcing','MMSE');
snapnow;

%% Part 3: MIMO-OFDM

% close all; clear all; clc;
% warning ('off','all');

% Take the OFDM symbol and put it through a 2x2 frequency selective MIMO link.
% You can assume perfect CSIT or CSIR, whichever you want. 
% The magic of OFDM and MIMO is the frequency selective MIMO channel 
% just becomes a bunch of independent flat fading MIMO channels. 

% assume perfect CSIR

%% Parmeter Setup

nChan = 3;                      % number of unique (random) Rayleigh channels
nSyms = 1e2/2;                     % number of symbols to transmit
M = 16;                         % modulation order: 16 (QAM)
k = log2(M);
nBits = nSyms * k;

% MIMO 
Mt = 2;
Mr = 2;

% OFDM
nSubcarrier = 64;               % number of subcarriers
nCP = 16;                       % length of cyclic prefix
nData = nSubcarrier - nCP;      % number of subcarriers used for data
nPilot = 4;                     % number of pilots

% single Rayleigh frequency selective channel with 4 taps by 802.11a PHY standard
Ts = 4e-6;                      % symbol time per subchannel (sampling period of channel)
Fd = 0;                         % maximum Doppler frequency shift (Hz)
tau = [0 1e-5 3.5e-5 12e-5];    % path delays for 4 paths
pdb = [0 -1 -1 -3];             % average path power gains in each path
h = rayleighchan(Ts, Fd, tau, pdb);
h.StoreHistory = 0;
h.StorePathGains = 1;
h.ResetBeforeFiltering = 1;

% SNR
EbNo = -10:2:30;
snrVector = EbNo + 10*log10(k) + 10*log10(nSubcarrier/(nSubcarrier+nCP));

% initialize
nMIMOequalizers = 3;
berOFDMZeroForcing = zeros(nChan, length(snrVector), nMIMOequalizers);
berOFDMmmse = zeros(nChan, length(snrVector), nMIMOequalizers);
H = zeros(Mr, Mt, nData*nSyms*k);

% order:
% data src - MIMO (3) - OFDM (2) - AWGN - OFDM (2) - MIMO (3) - data sink
% assume perfect CSIT; estimate CSIR

%% OFDM Zero-Forcing, MIMO Precoding/Zero-Forcing/MMSE

% initialize
U = zeros(Mr, Mt, nData*nSyms*k);
S = zeros(Mr, Mt, nData*nSyms*k);
V = zeros(Mr, Mt, nData*nSyms*k);
chan = zeros(nSubcarrier+nCP, nSyms);
txOFDM = zeros(nSubcarrier+nCP, nSyms*k*Mt);
prefiltered = zeros(Mr,1,nData*nSyms*k);
txMIMO = zeros(Mr,1,nData*nSyms*k);
postfiltered = zeros(Mr,1,nData*nSyms*k);
rxMIMO = zeros(Mr,1,nData*nSyms*k);

for i = 1:nChan
    fprintf('Channel: %d\t',i);
    
    % unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas
    H = ( randn(Mr, Mt, nData*nSyms*k) + 1j*randn(Mr, Mt, nData*nSyms*k) ) / sqrt(2);
    
    % generate a sequence of random message bits and QAM modulate
    msg = randi([0 M-1], 1, nData*nSyms*k*Mt);
    bits = reshape(msg, 2, []);
    dataMod = qammod(bits, M);
        
    % reshape for OFDM framing 
    txMsg = reshape(dataMod, nData,[]);
    
    % OFDM: 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame = zeros(nSubcarrier, nSyms*k*Mt);
    frame(dataIdx,:) = txMsg;              % data
    frame(nData+1:nData+nPilot,:) = 1;      % pilot
    dataIFFT = ifft(frame,64);              % 64-point IFFT
    
    % OFDM: insert cyclic prefix (CP)
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];
    
    % OFDM encode (flat fading Rayleigh channel)
    for kk = 1:nSyms*k*Mt
        chan(:,kk) = filter(h,ones((nSubcarrier+nCP),1));
        txOFDM(:,kk) = chan(:,kk) .* dataIFFTWithCP(:,kk);
    end
    
    fprintf('SNR:\t');
    for j = 1:length(snrVector)
        fprintf('%d\t',j);
        % add noise from OFDM modulation
        noise = (randn(nSubcarrier+nCP,nSyms*k*Mt) + 1j*randn(nSubcarrier+nCP,nSyms*k*Mt)) / sqrt(2);
        txNoisy = txOFDM + 10^(-snrVector(j)/10/2) * noise;
        
        % OFDM: take 64-point FFT back on data + zero + pilot portion (w/o CP)
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, 64); % 64-point FFT
        
        % OFDM: Equalize
        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:)) ./ conj(chan(nCP+1:end,:)));
        ofdmZF = rxFFT ./ W;
        ofdmRxData = ofdmZF(dataIdx,:);
        
        % OFDM frame
        OFDMsym = reshape(ofdmRxData, 1, []);
        
        % prepare to send over MIMO channel
        txMIMOsym = reshape(OFDMsym, Mt, 1, []);
            
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH MIMO precoding
        % precode and send over channel
        for bit = 1:nData*nSyms*k
            % decompose channel matrix H by SVD
            [U(:,:,bit), S(:,:,bit), V(:,:,bit)] = svd(H(:,:,bit));
            % pre-code data for each bit: inverting fading at transmitter (x = V * x_hat)
            prefiltered(:,:,bit) = V(:,:,bit) * txMIMOsym(:,:,bit);
            % send over the fading channel
            txMIMO(:,:,bit) = H(:,:,bit)*prefiltered(:,:,bit);
        end
        
        % add noise from MIMO channel
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        
        for bit = 1:nData*nSyms*k
           % post-code data for each bit: remove fading channel components
           postfiltered(:,:,bit) = U(:,:,bit)' * txMIMONoisy(:,:,bit);
           % recover data
           rxMIMO(:,:,bit) = S(:,:,bit)^-1 * postfiltered(:,:,bit);
        end
        rxMIMOPrecoded = rxMIMO;
        clear rxMIMO;
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH MIMO zero forcing 
        % pass through channel
        for bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        end
        % add noise from MIMO channel
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        clear W;
        for bit = 1:nData*nSyms*k
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit))^-1 * H(:,:,bit)';
           rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        end
        rxMIMOzf = rxMIMO;
        clear rxMIMO;
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH MIMO MMSE
                % pass through channel
        for bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        end
        % add noise from MIMO channel
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        
        clear W;
        for bit = 1:nData*nSyms*k
            W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit) + ...
                          + eye(Mt)*10^(-snrVector(j)/10/2) ...
                          )^-1 * H(:,:,bit)';
            rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        end
        rxMIMOmmse = rxMIMO;
        clear rxMIMO;
        
        % QAM demodulate and compute bit error rate
        rxDataPC = qamdemod(rxMIMOPrecoded, M);
        rxDataZF = qamdemod(rxMIMOzf, M);
        rxDataMMSE = qamdemod(rxMIMOmmse, M);
        
        rxDataMsgPC = reshape(rxDataPC, 1, []);
        rxDataMsgZF = reshape(rxDataZF, 1, []);
        rxDataMsgMMSE = reshape(rxDataMMSE, 1, []);
        
        [~,berOFDMZeroForcing(i,j,1)] = biterr(msg, rxDataMsgPC);
        [~,berOFDMZeroForcing(i,j,2)] = biterr(msg, rxDataMsgZF);
        [~,berOFDMZeroForcing(i,j,3)] = biterr(msg, rxDataMsgMMSE);
        
    end   
    fprintf('\n');    
end

berOFDMZeroForcing = mean(berOFDMZeroForcing,1);
berOFDMZeroForcing = permute(berOFDMZeroForcing, [3 2 1]);

%% OFDM MMSE, MIMO Precoding/Zero-Forcing/MMSE

% initialize
U = zeros(Mr, Mt, nData*nSyms*k);
S = zeros(Mr, Mt, nData*nSyms*k);
V = zeros(Mr, Mt, nData*nSyms*k);
chan = zeros(nSubcarrier+nCP, nSyms);
txOFDM = zeros(nSubcarrier+nCP, nSyms*k*Mt);
prefiltered = zeros(Mr,1,nData*nSyms*k);
txMIMO = zeros(Mr,1,nData*nSyms*k);
postfiltered = zeros(Mr,1,nData*nSyms*k);
rxMIMO = zeros(Mr,1,nData*nSyms*k);

for i = 1:nChan
    fprintf('Channel: %d\t',i);
    
    % unique MIMO channel for 'Mr' receive and 'Mt' transmit antennas
    H = ( randn(Mr, Mt, nData*nSyms*k) + 1j*randn(Mr, Mt, nData*nSyms*k) ) / sqrt(2);
    
    % generate a sequence of random message bits and QAM modulate
    msg = randi([0 M-1], 1, nData*nSyms*k*Mt);
    bits = reshape(msg, 2, []);
    dataMod = qammod(bits, M);
        
    % reshape for OFDM framing 
    txMsg = reshape(dataMod, nData,[]);
    
    % OFDM: 48 = data, 4 = pilot, rest (12) = zeros to reduce ISI
    randomIdx = randperm(nSubcarrier);
    dataIdx = randomIdx(1:nData);
    frame = zeros(nSubcarrier, nSyms*k*Mt);
    frame(dataIdx,:) = txMsg;              % data
    frame(nData+1:nData+nPilot,:) = 1;      % pilot
    dataIFFT = ifft(frame,64);              % 64-point IFFT
    
    % OFDM: insert cyclic prefix (CP)
    dataIFFTWithCP = [dataIFFT(nSubcarrier-nCP+1:nSubcarrier,:); dataIFFT];
    
    % OFDM encode (flat fading Rayleigh channel)
    for kk = 1:nSyms*k*Mt
        chan(:,kk) = filter(h,ones((nSubcarrier+nCP),1));
        txOFDM(:,kk) = chan(:,kk) .* dataIFFTWithCP(:,kk);
    end
    
    fprintf('SNR:\t');
    for j = 1:length(snrVector)
        fprintf('%d\t',j);
        % add noise from OFDM modulation
        noise = (randn(nSubcarrier+nCP,nSyms*k*Mt) + 1j*randn(nSubcarrier+nCP,nSyms*k*Mt)) / sqrt(2);
        noiseSNR = 10^(-snrVector(j)/10/2);
        txNoisy = txOFDM + noiseSNR * noise;
        
        % OFDM: take 64-point FFT back on data + zero + pilot portion (w/o CP)
        rxWithoutCP = txNoisy(nCP+1:(nSubcarrier+nCP),:);
        rxFFT = fft(rxWithoutCP, 64); % 64-point FFT
        
        % OFDM: Equalize
        W = ((conj(chan(nCP+1:end,:)) .* chan(nCP+1:end,:) + ...
            ones(nSubcarrier, nSyms*k*Mt).*noiseSNR) ./ conj(chan(nCP+1:end,:)));
        ofdmMMSE = rxFFT ./ W;
        ofdmRxData = ofdmMMSE(dataIdx,:);
        
        % OFDM frame
        OFDMsym = reshape(ofdmRxData, 1, []);
        
        % prepare to send over MIMO channel
        txMIMOsym = reshape(OFDMsym, Mt, 1, []);
            
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH MIMO precoding
        % precode and send over channel
        for bit = 1:nData*nSyms*k
            % decompose channel matrix H by SVD
            [U(:,:,bit), S(:,:,bit), V(:,:,bit)] = svd(H(:,:,bit));
            % pre-code data for each bit: inverting fading at transmitter (x = V * x_hat)
            prefiltered(:,:,bit) = V(:,:,bit) * txMIMOsym(:,:,bit);
            % send over the fading channel
            txMIMO(:,:,bit) = H(:,:,bit)*prefiltered(:,:,bit);
        end
        
        % add noise from MIMO channel
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        
        for bit = 1:nData*nSyms*k
           % post-code data for each bit: remove fading channel components
           postfiltered(:,:,bit) = U(:,:,bit)' * txMIMONoisy(:,:,bit);
           % recover data
           rxMIMO(:,:,bit) = S(:,:,bit)^-1 * postfiltered(:,:,bit);
        end
        rxMIMOPrecoded = rxMIMO;
        clear rxMIMO;
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH MIMO zero forcing 
        % pass through channel
        for bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        end
        % add noise from MIMO channel
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        clear W;
        for bit = 1:nData*nSyms*k
           W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit))^-1 * H(:,:,bit)';
           rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        end
        rxMIMOzf = rxMIMO;
        clear rxMIMO;
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH MIMO MMSE
                % pass through channel
        for bit = 1:nData*nSyms*k
            txMIMO(:,:,bit) = H(:,:,bit) * txMIMOsym(:,:,bit);
        end
        % add noise from MIMO channel
        noiseChannel = (randn(Mr,1,nData*nSyms*k) + 1j*randn(Mr,1,nData*nSyms*k)) / sqrt(2);
        txMIMONoisy = txMIMO + 10^(-snrVector(j)/10/2) * noiseChannel;
        
        clear W;
        for bit = 1:nData*nSyms*k
            W(:,:,bit) = (H(:,:,bit)' * H(:,:,bit) + ...
                          + eye(Mt)*10^(-snrVector(j)/10/2) ...
                          )^-1 * H(:,:,bit)';
            rxMIMO(:,:,bit) = W(:,:,bit) * txMIMONoisy(:,:,bit);
        end
        rxMIMOmmse = rxMIMO;
        clear rxMIMO;
        
        % QAM demodulate and compute bit error rate
        rxDataPC = qamdemod(rxMIMOPrecoded, M);
        rxDataZF = qamdemod(rxMIMOzf, M);
        rxDataMMSE = qamdemod(rxMIMOmmse, M);
        
        rxDataMsgPC = reshape(rxDataPC, 1, []);
        rxDataMsgZF = reshape(rxDataZF, 1, []);
        rxDataMsgMMSE = reshape(rxDataMMSE, 1, []);
        
        [~,berOFDMmmse(i,j,1)] = biterr(msg, rxDataMsgPC);
        [~,berOFDMmmse(i,j,2)] = biterr(msg, rxDataMsgZF);
        [~,berOFDMmmse(i,j,3)] = biterr(msg, rxDataMsgMMSE);
        
    end   
    fprintf('\n');    
end

berOFDMmmse = mean(berOFDMmmse,1);
berOFDMmmse = permute(berOFDMmmse, [3 2 1]);

%% Plot BER Curves
figure('Renderer', 'painters', 'Position', [300 300 900 600])
semilogy(EbNo, berOFDMZeroForcing(1,:), '-bo', ...
         EbNo, berOFDMZeroForcing(2,:), '-b^', ...
         EbNo, berOFDMZeroForcing(3,:), '-bv', 'LineWidth',1);
hold on;
semilogy(EbNo, berOFDMmmse(1,:), '-ko', ...
         EbNo, berOFDMmmse(2,:), '-k^', ...
         EbNo, berOFDMmmse(3,:), '-kv', 'LineWidth',1);
grid on;
xlim([EbNo(1)-2 EbNo(end)+2]);
legend('OFDM ZF, MIMO Precoding','OFDM ZF, MIMO Zero Forcing','OFDM ZF, MIMO MMSE', ...
       'OFDM MMSE, MIMO Precoding','OFDM MMSE, MIMO Zero Forcing','OFDM MMSE, MIMO MMSE');
title(sprintf('MIMO-OFDM: BER Curves by Equalizers, M = %d QAM', M));
set(gca, 'FontWeight','bold','LineWidth',1);
xlabel('Eb/No (dB)');
ylabel('Bit Error Rate (avg over 3 flat fading channels)');
snapnow;
    
    


##### SOURCE END #####
--></body></html>